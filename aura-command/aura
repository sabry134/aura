#!/bin/sh

# Files to store state and configuration
START_TIME_FILE="$HOME/.aura_start_time"       # When the bot was started
RUNNING_PID_FILE="$HOME/.aura_running_pid"       # Process ID of the running bot
LOG_FILE="$HOME/.aura_bot.log"                   # Bot log file (assumed)
ERROR_LOG_FILE="$HOME/.aura_errors.log"          # Error log file (assumed)
GUILDS_FILE="$HOME/.aura_guilds"                 # Fallback guild list file (assumed)
WEBHOOK_FILE="$HOME/.aura_webhooks"              # List of webhook URLs (assumed)
TOKEN_FILE="$HOME/.aura_token"                   # Bot token storage

# File to store the last-used bot file and background flag.
BOT_CONFIG_FILE="$HOME/.aura_bot_config"         # Contains: [file] [bg_flag] (bg_flag is 1 if background, 0 otherwise)

error() {
    echo "Error: $1" >&2
    exit 1
}

####################################
# Token Management
####################################

# Ensures a token is set; if not, exits with an error.
require_token() {
    if [ ! -f "$TOKEN_FILE" ]; then
        error "Bot token is not set. Use 'aura set-token [token]' to set the token."
    fi
}

# Set the bot token
set_token() {
    TOKEN="$1"
    [ -z "$TOKEN" ] && error "Usage: aura set-token [token]"
    echo "$TOKEN" > "$TOKEN_FILE"
    echo "Token set."
}

# Remove the bot token
remove_token() {
    if [ -f "$TOKEN_FILE" ]; then
        rm "$TOKEN_FILE"
        echo "Token removed."
    else
        echo "No token is set."
    fi
}

####################################
# Utility Functions
####################################

# Cleanup for foreground processes
cleanup() {
    [ -f "$START_TIME_FILE" ] && { rm "$START_TIME_FILE"; echo "Bot stopped, timer reset."; }
    [ -f "$RUNNING_PID_FILE" ] && rm "$RUNNING_PID_FILE"
}

# Calculate and display bot uptime
uptime_cmd() {
    if [ ! -f "$START_TIME_FILE" ]; then
        echo "Error: Bot has not started yet."
        exit 1
    fi
    START_TIME=$(cat "$START_TIME_FILE")
    CURRENT_TIME=$(date +%s)
    DIFF=$((CURRENT_TIME - START_TIME))
    DAYS=$((DIFF / 86400))
    HOURS=$(( (DIFF % 86400) / 3600 ))
    MINUTES=$(( (DIFF % 3600) / 60 ))
    SECONDS=$((DIFF % 60))
    echo "Bot uptime: ${DAYS}d ${HOURS}h ${MINUTES}m ${SECONDS}s"
}

####################################
# Bot Control Functions
####################################

# Run the bot file; BACKGROUND=1 uses pm2, else foreground.
run_bot() {
    FILE="$1"
    BG="$2"
    if [ ! -f "$FILE" ]; then
        error "File '$FILE' not found."
    fi
    date +%s > "$START_TIME_FILE"
    # Save the bot configuration (file and bg flag)
    echo "$FILE $BG" > "$BOT_CONFIG_FILE"
    if [ "$BG" -eq 1 ]; then
        command -v pm2 >/dev/null 2>&1 || error "pm2 is required but not installed. Install it with 'npm install -g pm2'"
        echo "Running '$FILE' in background using pm2..."
        if pm2 list | grep -q "aura-$FILE"; then
            echo "Bot is already running in the background using pm2."
        else
            pm2 start "$FILE" --name "aura-$FILE"
        fi
        PM2_PID=$(pm2 pid "aura-$FILE")
        echo "$PM2_PID" > "$RUNNING_PID_FILE"
    else
        echo "Running '$FILE' normally..."
        trap cleanup EXIT
        node "$FILE" &
        echo "$!" > "$RUNNING_PID_FILE"
        wait
    fi
}

# Restart the bot with the provided file and mode (-b for background)
restart_bot() {
    FILE="$1"
    MODE="$2"  # "-b" if background, else empty
    if [ -f "$RUNNING_PID_FILE" ]; then
        PID=$(cat "$RUNNING_PID_FILE")
        if kill -0 "$PID" >/dev/null 2>&1; then
            echo "Stopping the bot..."
            kill "$PID"
            wait "$PID" 2>/dev/null
            echo "Bot stopped."
        fi
        rm "$RUNNING_PID_FILE"
    fi
    echo "Restarting the bot..."
    if [ "$MODE" = "-b" ]; then
        command -v pm2 >/dev/null 2>&1 || error "pm2 is required but not installed. Install it with 'npm install -g pm2'"
        if pm2 list | grep -q "aura-$FILE"; then
            pm2 restart "aura-$FILE" || error "Failed to restart bot with pm2."
        else
            pm2 start "$FILE" --name "aura-$FILE"
        fi
        PM2_PID=$(pm2 pid "aura-$FILE")
        echo "$PM2_PID" > "$RUNNING_PID_FILE"
    else
        node "$FILE" &
        echo "$!" > "$RUNNING_PID_FILE"
        trap cleanup EXIT
        wait
    fi
    date +%s > "$START_TIME_FILE"
}

# Stop the bot (no file required)
stop_bot() {
    if [ -f "$RUNNING_PID_FILE" ]; then
        PID=$(cat "$RUNNING_PID_FILE")
        if kill -0 "$PID" >/dev/null 2>&1; then
            echo "Stopping the bot..."
            kill "$PID"
            wait "$PID" 2>/dev/null
            echo "Bot stopped."
        fi
        rm "$RUNNING_PID_FILE"
    fi
    if command -v pm2 >/dev/null 2>&1; then
        if pm2 list | grep -q "aura-"; then
            echo "Stopping PM2-managed bot..."
            pm2 delete all 2>/dev/null
        fi
    fi
    [ -f "$START_TIME_FILE" ] && rm "$START_TIME_FILE"
}

####################################
# Bot Info Functions
####################################

# Display internal debugging information
debug_info() {
    echo "----- Bot Debug Information -----"
    if [ -f "$START_TIME_FILE" ]; then
        START_TIME=$(cat "$START_TIME_FILE")
        echo "Start Time (epoch): $START_TIME"
        echo "Uptime: $(uptime_cmd)"
    else
        echo "Start Time: Not set (bot may not be running)"
    fi
    if [ -f "$RUNNING_PID_FILE" ]; then
        echo "Running PID: $(cat "$RUNNING_PID_FILE")"
    else
        echo "Running PID: Not available"
    fi
    if command -v pm2 >/dev/null 2>&1; then
        echo "PM2 Process List:"
        pm2 list
    else
        echo "PM2: Not installed"
    fi
    echo "---------------------------------"
}

# Show status: uptime, process resource usage, system load, and ping
status() {
    echo "----- Bot Status -----"
    if [ -f "$START_TIME_FILE" ]; then
        uptime_info=$(uptime_cmd)
        echo "$uptime_info"
    else
        echo "Bot uptime: Not available (bot may not be running)"
    fi
    if [ -f "$RUNNING_PID_FILE" ]; then
        PID=$(cat "$RUNNING_PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            proc_usage=$(ps -p "$PID" -o %cpu,%mem --no-headers)
            echo "Process CPU and Memory usage (%CPU, %MEM): $proc_usage"
        else
            echo "Process is not running."
        fi
    else
        echo "Process PID not found."
    fi
    sys_load=$(uptime_cmd | awk -F'load average:' '{ print $2 }')
    echo "System load averages:$sys_load"
    if command -v ping >/dev/null 2>&1; then
        ping_out=$(ping -c 1 google.com | grep 'time=')
        if [ -n "$ping_out" ]; then
            ping_time=$(echo "$ping_out" | sed -n 's/.*time=\([0-9.]*\) ms.*/\1/p')
            echo "Ping to google.com: ${ping_time} ms"
        else
            echo "Ping: Not available."
        fi
    else
        echo "Ping command not available."
    fi
    echo "----------------------"
}

####################################
# Additional Bot Commands
####################################

# Fetch latest logs from the bot (default: 20 lines)
logs() {
    LINES="${1:-20}"
    if [ -f "$LOG_FILE" ]; then
        tail -n "$LINES" "$LOG_FILE"
    else
        echo "No logs available."
    fi
}

# Show latest errors and stack traces (default: 20 lines)
errors() {
    if [ -f "$ERROR_LOG_FILE" ]; then
        tail -n 20 "$ERROR_LOG_FILE"
    else
        echo "No error logs available."
    fi
}

# Blacklist a guild (ban a server from using the bot)
blacklist_guild() {
    GUILD_ID="$1"
    if [ -z "$GUILD_ID" ]; then
        error "Guild ID is required."
    fi
    echo "Blacklist guild $GUILD_ID" >> "$GUILDS_FILE"
}

# Whitelist a guild
whitelist_guild() {
    GUILD_ID="$1"
    if [ -z "$GUILD_ID" ]; then
        error "Guild ID is required."
    fi
    sed -i "/$GUILD_ID/d" "$GUILDS_FILE"
    echo "Guild $GUILD_ID is now whitelisted."
}

# Add or update webhooks
set_webhook() {
    WEBHOOK_URL="$1"
    if [ -z "$WEBHOOK_URL" ]; then
        error "Webhook URL is required."
    fi
    echo "$WEBHOOK_URL" >> "$WEBHOOK_FILE"
    echo "Webhook set."
}

# Remove a webhook URL
remove_webhook() {
    WEBHOOK_URL="$1"
    if [ -z "$WEBHOOK_URL" ]; then
        error "Webhook URL is required."
    fi
    sed -i "/$WEBHOOK_URL/d" "$WEBHOOK_FILE"
    echo "Webhook removed."
}

####################################
# Command Parsing
####################################

# Main logic for handling command-line operations
case "$1" in
    set-token)
        set_token "$2"
        ;;
    remove-token)
        remove_token
        ;;
    start)
        run_bot "$2" "$3"
        ;;
    stop)
        stop_bot
        ;;
    restart)
        restart_bot "$2" "$3"
        ;;
    uptime)
        uptime_cmd
        ;;
    status)
        status
        ;;
    debug)
        debug_info
        ;;
    logs)
        logs "$2"
        ;;
    errors)
        errors
        ;;
    blacklist)
        blacklist_guild "$2"
        ;;
    whitelist)
        whitelist_guild "$2"
        ;;
    webhook-set)
        set_webhook "$2"
        ;;
    webhook-remove)
        remove_webhook "$2"
        ;;
    *)
        echo "Usage: $0 {set-token|remove-token|start|stop|restart|uptime|status|debug|logs|errors|blacklist|whitelist|webhook-set|webhook-remove}"
        exit 1
        ;;
esac
